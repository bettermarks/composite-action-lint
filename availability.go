package compositeactionlint

import (
	"slices"

	"github.com/rhysd/actionlint"
)

// Like https://github.com/rhysd/actionlint/blob/main/availability.go bu for
// https://docs.github.com/en/actions/reference/workflows-and-actions/metadata-syntax
// and sadly not autogenerated.
func MetadataKeyAvailability(key string) ([]string, []string) {
	// TODO: find out if 'vars' is available.
	// TODO: find out if 'runner' is available.

	// special functions
	sfInSteps := []string{"hashfiles"} // careful, we've lowercased it
	sfInIfs := []string{"success", "always", "cancelled", "failure"}

	switch key {
	case "runs.steps.continue-on-error":
		fallthrough
	case "runs.steps.env":
		fallthrough
	case "runs.steps.name":
		fallthrough
	case "runs.steps.run":
		fallthrough
	case "runs.steps.with":
		fallthrough
	case "runs.steps.working-directory":
		return []string{"env", "github", "inputs", "steps"}, sfInSteps
	case "runs.steps.if":
		return []string{"env", "github", "inputs", "steps"}, slices.Concat(sfInSteps, sfInIfs)
	case "outputs.<output_id>":
		return []string{"env", "github", "inputs", "steps"}, []string{}
	default:
		return nil, nil
	}
}

var ALSpecialFunctionNames = actionlint.SpecialFunctionNames

// Ensure the semantic checks in actionlint give the right error messaegs
func UpdateSpecialFunctionNames() {

	actionlint.SpecialFunctionNames = map[string][]string{
		"always":    {"runs.steps.if"},
		"cancelled": {"runs.steps.if"},
		"failure":   {"runs.steps.if"},
		"success":   {"runs.steps.if"},
		"hashfiles": {
			"runs.steps.continue-on-error",
			"runs.steps.env",
			"runs.steps.if",
			"runs.steps.name",
			"runs.steps.run",
			"runs.steps.with",
			"runs.steps.working-directory",
		},
	}
}
